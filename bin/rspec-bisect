#!/usr/bin/env ruby

$LOAD_PATH << File.expand_path(File.join(__FILE__, "..", "..", "lib"))

require 'yaml'
require 'optparse'
require 'open3'
require 'rspec-bisect'

options = {}
parser = OptionParser.new do |opts|
  opts.on('--order TYPE[:SEED]', 'Run examples by the specified order type.',
            '  [defined] examples and groups are run in the order they are defined',
            '  [rand]    randomize the order of groups and examples',
            '  [random]  alias for rand',
            '  [random:SEED] e.g. --order random:123') do |o|
              options[:order] = o
  end

  opts.on('--seed SEED', Integer, 'Equivalent of --order rand:SEED.') do |seed|
    options[:order] = "rand:#{seed}"
  end
end

original_args = ARGV.join(" ")
filtered_args = []

while ARGV.size > 0 do
  begin
    parser.parse!
  rescue OptionParser::InvalidOption => e
    filtered_args.push(e.to_s.sub(/invalid option:\s+/, ''))
  end
end

def order_for(tree, examples)
  tree.filter(examples).to_a.flatten.drop(1)
end

def bisect(candidates)
  low  = 0
  high = candidates.length - 1
  while low < high do
    puts "Searching #{candidates[low..high].count} examples"
    mid = (low + high) / 2
    if yield(candidates[low..mid])
      low = mid + 1
    else
      high = mid
    end
  end
  candidates[low]
end

bisect_command = "rspec #{filtered_args.join(" ")} \
                  --require rspec-bisect/ordering/specified"
recording_command = "rspec #{original_args} \
                     --require rspec-bisect/formatters/recording \
                     --format RSpecBisect::Formatters::Recording"

puts "Recording failing example order"
Open3.popen2e(recording_command) do |stdin, stdout_and_stderr, wait_thr|
  out = stdout_and_stderr.read
  if wait_thr.value.success?
    $stderr.puts "Errr... this passed:"
    $stderr.write out
    exit(1)
  elsif !(out =~ /Finished.*seconds/)
    $stderr.puts "Recording seems to have failed:"
    $stderr.write out
    exit(1)
  end
end

tree     = YAML.load_file("tree.yml")
examples = tree.leaves
failure  = examples.pop

culprit = bisect(examples) do |candidates|
  items = candidates + [failure]
  order = order_for(tree, items)
  File.open("order.log", "w") { |f| f.puts(order) }
  result = false
  Open3.popen3(bisect_command) do |_i, _o, _e, wait_thr|
    result = wait_thr.value.success?
  end
  result
end

puts
puts "The culprit appears to be at #{culprit}"
