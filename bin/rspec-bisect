#!/usr/bin/env ruby

$LOAD_PATH << File.expand_path(File.join(__FILE__, "..", "..", "lib"))

require 'yaml'
require 'optparse'
require 'open3'
require 'rspec/reducer/tree/node'

options = {}
parser = OptionParser.new do |opts|
  opts.on('--order TYPE[:SEED]', 'Run examples by the specified order type.',
            '  [defined] examples and groups are run in the order they are defined',
            '  [rand]    randomize the order of groups and examples',
            '  [random]  alias for rand',
            '  [random:SEED] e.g. --order random:123') do |o|
              options[:order] = o
  end

  opts.on('--seed SEED', Integer, 'Equivalent of --order rand:SEED.') do |seed|
    options[:order] = "rand:#{seed}"
  end
end

original_args = ARGV.join(" ")

filtered_args = []
while $*.size > 0 do
  begin
    parser.parse!
  rescue OptionParser::InvalidOption => e
    filtered_args.push(e.to_s.sub(/invalid option:\s+/, ''))
  end
end
BISECT_COMMAND = "rspec #{filtered_args.join(" ")} --require rspec/reducer/ordering/specified"

recording_command = "rspec #{original_args} --require rspec/reducer/formatters/recording -f RSpec::Reducer::Formatters::Recording"
puts "Recording failing example order"
Open3.popen2e(recording_command) do |stdin, stdout_and_stderr, wait_thr|
  if wait_thr.value.success?
    $stderr.puts "Errr... this passed"
    $stderr.write stdout_and_stderr.read
  end
end

tree    = YAML.load_file("tree.yml")
nodes   = tree.children
FAILURE = tree.to_a.flatten.last
FAILURE_PATH = tree.path_to(FAILURE).drop(1)

def order_for(ns, prefix)
  (prefix + ns.map(&:to_a).flatten.reject{|n| n == FAILURE} + FAILURE_PATH)
end

def search_in(nodes, prefix)
  low     = 0
  high    = nodes.length - 1
  mid     = (low + high) / 2
  while low < high do
    items = nodes[low..mid]
    File.open("order.log", "w") { |f| f.puts(order_for(items, prefix)) }
    puts "Running ~#{order_for(items, prefix).count} specs"
    Open3.popen3(BISECT_COMMAND) do |_stdin, _stdout, _stderr, wait_thr|
      if wait_thr.value.success?
        low = mid + 1
      else
        high = mid
      end
      mid = (low + high) / 2
    end
  end
  nodes[low]
end

puts "Reducing example set"
prefix  = []
node = nil
loop do
  node = search_in(nodes, prefix)
  break if node.children.empty?
  prefix << node.name
  nodes = node.children
end

puts
puts "The culprit appears to be at #{node.name}"
